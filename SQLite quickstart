지금까지 관계형 데이터베이스가 무엇인지, 데이터가 데이터베이스 내부에서 어떻게 구성되는지, 그리고 관계형 데이터베이스 관리 시스템 (RDBMS)을 사용하여 데이터베이스에 대한 질문을하고 (쿼리를 작성하여) 얻을 수있는 방법에 대해 조금 이야기했습니다. 의미있는 결과. 이제 기본 개념과 용어를 살펴 보았으므로 쿼리 연습을 시작할 수 있도록 작동하는 SQL 환경을 설정해야합니다. 이 장에서는 SQL 지식을 테스트하는 데 도움이되는 많은 연습 및 자체 평가 질문뿐만 아니라이 책과 함께 사용되는 리소스에 익숙해집니다.

### Introducing the sTunes Database 


온라인 소매 음악 회사에서 음악 판매 데이터에 대한 분석을 수행하기 위해 방금 SQL 데이터 분석가로 고용되었다고 가정 해보십시오. 회사 데이터베이스에 대한 액세스 권한이 부여되고 여기에 제품 정보 (이 경우 노래 및 앨범), 개인 고객 정보, 직원 기록 및 판매 데이터가 포함되어 있다고 알려집니다. 경영진은 sTunes 데이터베이스의 데이터에 판매, 고객 인구 통계 및 회사가 서비스를 개선하거나 확장 할 수있는 방법에 대한 유용한 정보가 포함되어 있는지 알고 싶어합니다. 데이터베이스를 분석하고 데이터에 대해 발견 한 통찰력을 경영진에게 제시하는 작업이 제공됩니다. SQL로 모든 분석을 수행합니다. 이 작업을 시작하려면이 데이터베이스의 복사본을 컴퓨터에 다운로드해야합니다.



### Introducing DB Browser for SQLite 

1 장 끝에서 언급했듯이 "SQL Lite"라고하는 SQLite라는 RDBMS로 작업 할 것입니다. SQLite는 샘플 데이터베이스의 특정 구현 또는 프로토콜이지만 웹 브라우저가 페이지를 해석하는 데 사용되는 것처럼 데이터베이스를 "찾아보기"하는 데 사용할 수있는 실제 응용 프로그램 (SQL 브라우저라고도 함)을 다운로드해야합니다. 인터넷. SQLite는 SQLite와 호환되는 데이터베이스 파일을 생성, 설계 및 편집하는 데 사용되는 고품질의 시각적 오픈 소스 도구 인 DB 브라우저와 함께 제공됩니다. 데이터베이스 생성, 검색 및 데이터 편집을 원하는 사용자와 개발자를위한 것입니다.



### How to Test Your SQL Knowledge 
다른 기술과 마찬가지로 연습은 숙달의 열쇠입니다. 이 책은 샘플 데이터베이스의 예제를 제공하는 것 외에도 SQL에 대해 새로 습득 한 지식을 평가하기 위해 다음 장에서 두 가지 유형의 연습을 제공합니다. "ON YOUR OWN"이라고 표시된 연습을 통해 새로운 개념이 도입 된 후 즉시 기술을 빠르게 연습 할 수 있습니다. 이름에서 알 수 있듯이 이러한 질문에는 서면 솔루션이 없지만 지나치게 어렵지 않습니다. 또 다른 형태의 자체 평가는 "데이터 분석 체크 포인트"입니다. 이러한 연습은 더 어렵고 이전 장에서 설명한 개념에 대한 지식이 필요할 수 있습니다. 부록 I에서 모든 데이터 분석 체크 포인트에 대한 자세한 솔루션을 찾을 수 있습니다.


### Type Out Every Code Example by Hand 

이 텍스트의 디지털 버전에 액세스 할 수있는 경우 코딩 예제를 SQL 브라우저에 복사하여 붙여 넣지 마십시오! 이 조언은 특히 이전에 SQL을 경험하지 않은 초보 학생에게 적용됩니다. 나는 단순히 기존 코드 예제 나 연습을 RDBMS 환경에 복사하고 그들이하는 일을 관찰함으로써 프로그래밍 언어를 배울 수 있다는 생각에 매우 반대합니다. 복사 및 붙여 넣기는 쿼리를 직접 다시 작성하여 활성화하는 구문, 철자 및 근육 메모리를 우회합니다. 다른 소스의 코드를 붙여 넣으면 코드에 진단하기 어려운 서식 오류가 발생할 수 있습니다. 예를 들어, 워드 프로세서 형식의 따옴표가 포함 된 코드를 붙여 넣으면 DB Browser가 이러한 기호를 작은 따옴표로 해석하지 않기 때문에 구문 오류가 발생하는 경우가 많습니다. 우리가하는 실수는 성공만큼이나 중요합니다. 실행하려는 SQL 문에서 기괴한 구문 오류가 발생하는 경우 가장 좋은 방법은 모든 것을 삭제하고 처음부터 다시 쿼리를 작성하는 것입니다.


### Convert SQL Queries to Natural Language Questions 

질문에 답하거나 쿼리를 작성할 때 결과를 실제 질문에 대한 답으로 생각하십시오. "고객 테이블에 몇 개의 항목이 있습니까?"라고 생각하는 대신 "고객이 몇 명입니까?"라고 생각합니다. 이 책은 계속 확장되는 도구 상자에서 SQL을 도구로 사용하여 경력을 시작하거나 향상시키는 데 도움을주기위한 것입니다. 관리자와 동료로부터 받게되는 질문은 실제 질문이 될 것이므로 실제 질문을 SQL 문으로 전환 한 다음 다시 실제 답변으로 바꾸는 기술을 배우는 것이 중요합니다.


### Treat This Book Like a Reference Guide 

우리 독자 중 일부는 이미 SQL에 어느 정도 익숙 할 것이며 특정 섹션으로 건너 뛰기를 원할 수도 있습니다. 우리는 독자들이 텍스트를 쉽게 탐색하거나 이미 배운 개념을 검토하기 위해 빠르게 돌아갈 수 있도록 장 제목 내에 SQL 키워드 (각 장에서 논의 됨)를 포함하도록이 책을 설계했습니다. 빠른 탐색 지원 외에도 장별 SQL 키워드 목록이 포함 된 두 번째 부록과 가능한 한 빨리 쿼리를 작성할 수 있도록 몇 가지 독립 실행 형 예제가 포함되어 있습니다. 이 책을 책상 옆에두고 필요한만큼 자주 참조하시기 바랍니다.


# Chapter 3. Exploring a Database in SQLite 


##​ Launching the SQL software



##​ Opening a database file

##​ The Database Structure tab

##​ The Browse Data tab

##​ The Execute SQL tab

SQL 실행 탭은 SQL 문을 작성하는 곳입니다. SQL 실행 탭에는 쿼리 창, 결과 창 및 메시지 창의 세 가지 주요 구성 요소 창이 있습니다. 그림 29와 같이 쿼리 창에 다음 SQL 코드를 작성하여이 세 창을 살펴 보겠습니다.
 SELECT
    *
에서
    앨범; 이 SQL 문은 albums 테이블에서 모든 필드 (* 기호는 "모든 필드"를 나타냄)를 선택하고 쿼리 창 위의 재생 단추를 누르면 아래 결과 창에 해당 필드와 해당 필드의 데이터를 표시합니다. 그림 29에서 볼 수 있듯이 왼쪽의 Play 버튼은 창에 작성된 모든 SQL 문을 실행합니다. 오른쪽의 재생 버튼은 커서가있는 SQL 문만 실행합니다 (한 번에 하나의 문만 실행).
	
NOTE) 기본 쿼리로 시작하므로 한 번에 하나의 SQL 문만 실행합니다. 고급 쿼리는 동시에 실행되는 여러 문을 사용할 수 있습니다. 문을 개별적으로 실행하는 기능은 다중 문 쿼리에서 유용합니다. 실행 창에 완전한 SQL 문이 하나만있는 경우 이러한 재생 단추는 기본적으로 동일한 작업을 수행합니다.

결과 창에는 쿼리에서 생성 된 출력이 나열됩니다. 한 번에 화면에서 볼 수있는 것보다 더 많은 결과가있는 경우 (그림 30) 브라우저는 모든 결과를 탐색 할 수있는 스크롤 막대를 제공합니다. 화면에 표시되는 내용 (이 경우 5 개의 결과 만)인지, 전체 쿼리를 나타내는 지 또는 사용 가능한 데이터가 더 있는지 확인하는 또 다른 방법이 있습니다. 결과 창 아래에는 쿼리에 대한 정보 메시지를 표시하는 메시지 창이 있습니다.
 »SQL 문에서 반환 된 행 수
 »쿼리 또는 SQL 문을 실행하는 데 걸린 시간
 »SQL 문에 오류가있는 경우 오류 메시지


##​ Viewing query results

가장 먼저 확인한 것은 쿼리가 347 행의 데이터를 반환했다는 것입니다. 스크롤바가 보이지 않으면이 메시지가 아래로 스크롤하라는 알림 역할을합니다. 두 번째로 관찰 한 것은 쿼리가 9 밀리 초 (약칭 9ms) 내에 반환되었다는 것입니다. 쿼리를 처리하는 데 걸리는 시간을 확인하는 것이 왜 중요한지 궁금 할 것입니다. 이 경우에는 아무 것도 말해주지 않습니다. 그러나 고급 쿼리가있는 대규모 데이터베이스에서는 데이터를 반환하는 데 훨씬 더 오래 걸릴 수 있습니다. 소요되는 시간은 데이터베이스가 최적화되고 구조화되는 방식에 따라 달라집니다. 여러 테이블로 작업 할 때 6 장에서 데이터베이스 구조에 대해 자세히 설명합니다.


##​ Data Analysis Checkpoint



#Chapter 4. Getting Started with Queries

SQL은 사용자에게 다양한 명령을 제공하는 강력하고 강력한 언어입니다. 이 책에서 보여줄 수있는 것보다 더 많은 명령이 있지만 즉시 실험을 시작할 수있는 간단하고 사용하기 쉬운 명령이 몇 가지 있습니다. 이 장에서는 좋은 쿼리를 작성하고 결과를 형식화하는 기본 사항을 다룹니다. 이 장을 마치면 특정 데이터베이스에서 개별 필드를 선택하고 해당 필드를 알파벳 순서로 표시 할 수 있습니다. 시작하자!

### Adding Comments to Queries
첫 번째 SQL 쿼리 작성을 시작하기 전에 주석 작성을 살펴 보겠습니다. 주석은 작성한 SQL 문에 대한 통찰력과 작성 정보를 추가하는 데 사용되는 일반 영어 문장입니다. SQL 쿼리에 주석을 사용하는 것은 업계 모범 사례로 간주됩니다. 이는 SQL 작성자와 작성자를 뒤 따르는 사람 모두에게 주어진 SQL 문의 의도와 기능에 대한 이해와 컨텍스트를 빠르게 얻을 수 있도록 도와줍니다.

댓글을 작성하는 방법에는 두 가지가 있습니다. 두 개의 하이픈 (-)을 사용하여 쿼리 창에 작성된 모든 항목 앞에는 해당 줄에 주석이 생성됩니다. 이 예는 1 행에 작성된 주석을 보여줍니다 (그림 32).

주석 블록은 여러 줄 주석입니다. 앞 슬래시와 별표 기호를 사용하여 블록 / *를 열고, 별표와 앞 슬래시 * /를 사용하여 블록을 닫습니다. 여는 기호와 닫는 기호 사이에있는 모든 것은 주석의 일부가됩니다 (그림 33).

### The Structure of a Basic Query 

쿼리를 작성하는 것은 자연어로 질문하는 것과 같습니다. 어구, 세부 사항, 단어 순서가 중요합니다. 질문이 자세할수록 답이 더 정확 해집니다. SQL 쿼리를 생성 할 때 다음 다섯 가지 질문을 고려해야합니다. 
 어떤 데이터베이스에 대해 이야기하고 있습니까? 
 해당 데이터베이스 내의 어떤 테이블에서 데이터를 요청합니까? 
 해당 테이블 내의 어떤 필드에 관심이 있습니까? 
 데이터를 제외하거나 필터링하거나 범위 또는 기간을 생략 하시겠습니까? 
 하나의 간결한 문장에서 우리의 쿼리는 무엇을합니까? 
앞서 언급 한 질문의 목적은 우리가 매일 사용하는 자연어와 SQL 언어 사이에 다리를 놓는 데 도움이되는 것입니다. 데이터 분석가로 고용 된 경우 상사 나 동료로부터 비즈니스에 대한 일반적인 질문을 받게됩니다. 이러한 일반 언어 질문에 답하려면 SQL 문으로 변환해야합니다. 쿼리 결과를받은 후에는 해당 결과를 모두가 액세스 할 수있는 자연 언어로 다시 변환해야합니다. 이것이 직업의 본질입니다.

 NOTE)  If you are having trouble with a query, refer to the five questions above. Contemplating these questions will help you write your query. 

### Start Writing Your Query

주석 블록을 마친 후 첫 번째 SQL 문 작성을 시작할 수 있습니다. 하지만 그렇게하려면 대답 할 좋은 질문이 필요합니다. 2 장에서는이 책의 운영 시나리오 개념을 소개했습니다. 가상의 회사 인 sTunes의 데이터 분석가로 자신을 상상해보십시오. 3 장에서 sTunes 데이터베이스를 살펴보면서 sTunes는 온라인 음악을 판매하고 아티스트, 트랙 및 앨범의 디지털 라이브러리와 이러한 노래를 구매 한 고객 목록을 보유하고 있습니다. STunes 고객 서비스에서 기존의 모든 고객에게 새 프로모션 광고를 보내려고한다고 가정 해 보겠습니다. 고객 서비스는 고객 연락처 목록이 최신인지 알고 싶어하므로 데이터베이스에서 이름, 성 및 고객 이메일 주소 (사용 가능한 경우)의 전체 목록을 가져올 수 있는지 문의합니다. 이 질문에 어떻게 답해야할까요? 이 장의 앞부분에 나열된 질문에 답하는 것으로 시작하겠습니다.

1. What database are we speaking to? 
	이 경우 우리는 하나의 데이터베이스 만 다루고 있습니다. sTunes 데이터베이스는 이미 DB 브라우저에 열려 있어야합니다. 3 장을 통해 작업 한 후 브라우저를 닫은 경우 브라우저를 열고 sTunes 데이터베이스 파일을 다시 열어야 할 수 있습니다.
2. What table within that database are we requesting data FROM? 
	고객 정보를 찾고 있습니다. 데이터베이스 구조 탭을 보면 customers라는 테이블이 있음을 알 수 있습니다. 그 테이블은 유망 해 보입니다.
3. What fields within that table are we SELECTing to display? 
	이 질문은 데이터 찾아보기 탭에서 답변 할 수 있습니다. 해당 탭을 클릭하고 드롭 다운 메뉴에서 customers 테이블을 선택하면 이름, 성 및 이메일에 대한 필드가있는 것을 볼 수 있습니다.
4. Do we want to exclude any data, filter or omit any range or time period? 
	이 경우 sTunes 고객 서비스는 모든 고객의 목록을 원하므로 아무것도 생략하지 않는 것이 좋습니다.
5. In one concise sentence, what does our query do? 
	이 쿼리는 성, 이름, 이메일 주소를 선택

주석 블록을 추가 한 후 FROM customers를 입력하여 시작하십시오. 이것은 데이터를 찾을 테이블을 쿼리에 알려줍니다. 그런 다음 FROM 절 위에 키워드 SELECT를 입력하고 보려는 고객 테이블 내의 필드 이름을 입력합니다. 각 필드 이름은 쉼표로 구분됩니다. 쉼표는 SQL에 다른 필드를 예상하도록 지시합니다. 결과 코드는 다음과 같습니다.

이 SQL 쿼리를 작성한 후 메뉴 표시 줄에서 SQL 실행 재생 버튼을 클릭하여 문을 실행합니다. 쿼리 결과는 아래 결과 창에 표시됩니다 (그림 35). 메시지 창에는 쿼리가 3 밀리 초 동안 59 개 행 (레코드라고도 함)이 반환되었음을 표시합니다. 
자신 만의 방법 :»이 쿼리에 customers 테이블의 다른 필드를 추가합니다. sTunes 메일 링리스트에 회사 또는 전화 필드를 추가해보십시오. 쉼표를 추가하는 것을 잊지 마세요!

##​ Query notation techniques

##​ SQL query basics

코딩 구문과 코딩 규칙

1 장에서 언급했듯이 모든 쿼리는 SQL 브라우저에서 이해하기 위해 특정 구문을 따라야합니다. 쿼리를 작성할 때 SQL 브라우저가 사용자를 이해할 수 있는지 확인하는 것보다 훨씬 더 많은 것을 고려해야합니다. 다른 데이터베이스 사용자가 쿼리를 이해하고 따를 수 있어야합니다. 표준화되고 읽기 가능하며 일관된 방식으로 쿼리를 작성하는 관행을 코딩 규칙이라고합니다. 코딩 규칙은 데이터베이스 환경에 따라 다릅니다. 이 섹션에서는이 책에서 사용 된 코딩 규칙을 설명합니다.

이전 쿼리 예에서는 SELECT 키워드 뒤에 * 기호를 사용했습니다 (개별 필드를 지정하는 대신). 이 특수 기호는 테이블의 모든 필드를 검색하고 표시하도록 SQL 브라우저에 지시합니다. 이 기호는 일부 상황에서 유용하지만 대부분의 경우 특별히 선택하려는 필드를 결정하고 해당 필드를 이름으로 호출하는 것이 가장 좋습니다.

이 경우 문 끝에있는 세미콜론은 하나의 SQL 문만 작성하기 때문에 선택 사항입니다. 세미콜론은 SQL 문의 끝을 나타냅니다. 이 책에서 작성하게 될 대부분의 SQL 쿼리는 단일 문이므로 앞으로 세미콜론을 생략하겠습니다.

SELECT 절에서 표시 할 세 개의 필드를 선택했습니다. 모든 필드를 쉼표로 구분해야합니다 (마지막 필드 뒤 제외). 필드 사이에 쉼표를 생략하거나 마지막 필드 뒤에 쉼표를 추가하는 것은 쿼리 결과 창에 구문 오류가 표시되는 일반적인 구문 오류입니다.

코드는 여러 줄로 나뉘어져 있습니다. 전체 쿼리를 한 줄에 모두 작성할 수 있으며 SQL 브라우저는 여전히 코드를 인식하고 결과를 반환합니다. 그러나 새 줄에서 들여 쓰기 된 각 절의 내용을 사용하여 쿼리를 절로 분리하는 것이 가장 좋습니다. 이 텍스트의 뒷부분에서 쿼리는 훨씬 길어지고 더 많은 절이 포함됩니다. 들여 쓰기 및 공백으로 쿼리를 구성하면 가독성이 향상되고 다른 사용자가 따라갈 수 있습니다.

절은 특수 SQL 키워드 (SELECT, FROM 등)로 시작하는 SQL 문의 하위 섹션이며 추가 매개 변수 및 연산자를 포함 할 수 있습니다.

##​ Using an alias

데이터베이스의 기술 언어는 종종 비즈니스의 공통 언어와 다릅니다. 때로는 이전 데이터베이스 또는 한동안 필드 이름이 업데이트되지 않은 데이터베이스로 작업하게됩니다. 필드 이름에 별칭을 적용하면 (동료가 이해할 수있는 방식으로 데이터를 설명하기 위해) 제공하는 모든 보고서가 귀하와 함께 읽는 다른 사람 모두에게 훨씬 더 의미가 있습니다. 별칭을 사용하면 열 이름을 정리하고 쿼리 출력을 더 읽기 쉽고보기 좋게 만들려는 경우에도 유용합니다.

다음 예에서는 customers 테이블에서 선택한 필드 이름에 대한 별칭을 만드는 여러 가지 방법을 보여줍니다. 별칭은 항상 데이터베이스의 필드 이름 바로 뒤에 나열됩니다. 별칭은 일반적으로 AS 키워드와 연관되지만 필드 이름과 별칭 이름 사이에 AS 키워드를 사용하는 것은 대부분의 RDBMS 구현에서 선택 사항입니다.

##​ Sorting results alphabetically

##​ Limiting query results

##​ Data Analysis Checkpoint


# Chapter 5. Turning Data into Information

연구의이 시점에서 기본 SELECT 문 쿼리를 사용하여 데이터베이스 테이블에서 모든 필드 집합을 반환하고 선택한 필드별로 정렬 된 데이터를 볼 수 있습니다. 필드를 표시하고 정렬하는 것은 학습 여정의 중요한 첫 번째 단계이지만 더 구체적인 질문을 할 수 있도록 더 정확한 도구가 필요합니다. 이전 장의 데이터 분석 체크 포인트에서 B로 시작하는 고객의 성이 몇 명인지 물었습니다. 실습을 수행 한 경우 쿼리에서 많은 이름을 반환하지 않는 것을 확인했습니다. 이 경우 데이터를 성을 기준으로 알파벳순으로 정렬 한 다음 B로 끝나는 이름을 수동으로 계산하는 것이 쉬웠습니다.하지만 데이터베이스가 훨씬 더 크고 백만 명의 고객을 포함한다면 어떨까요? 정말로 모든 B 이름을 수동으로 계산 하시겠습니까? 다행히 SQL은 결과 집합 (즉, 쿼리 결과)을 매우 구체적인 데이터로 좁힐 수있을뿐만 아니라 사용자 지정 조건에 따라 데이터를 정렬하고 필터링 할 수있는 몇 가지 도구를 제공합니다. 이 새로운 진술이 무엇을 할 수 있는지 보자!

이 시점부터 텍스트에서 DB 브라우저 출력의 화면 캡처를 표시하지 않을 것입니다 (브라우저의 기능을 구체적으로 언급하지 않는 한). 대신 테이블 형식으로 쿼리 출력을 표시합니다 (그림 40).


##​ Operators in SQL

이러한 다양한 유형의 연산자를 결합하여 더 복잡한 쿼리를 만들 수 있습니다. 다양한 유형의 연산자를 결합하면 데이터 범위를 검색하거나 고유 한 조건을 만들 수 있습니다. 이 장에 나열 할 수있는 것보다 더 많은 옵션이 있지만 더 일반적인 옵션 중 일부를 살펴 보겠습니다.

다음 예에서는 sTunes 청구서 테이블에서 Total이라는 필드의 값을 늘리기 위해 SELECT 절과 함께 사용되는 산술 연산자를 볼 수 있습니다. 산술 연산은 세금, 추가 요금 또는 기타 수정 사항을 숫자 데이터에 추가해야 할 때 유용합니다.

다양한 SQL 버전 간에는 약간의 미묘한 차이가 있습니다. SQLite는 모듈로를 다음과 같이 취급합니다. % 연산자는 두 피연산자의 데이터 유형을 INTEGER 유형으로 변경 한 다음 왼쪽 정수를 오른쪽 정수로 나눈 후 나머지를 계산합니다. 이는 결과가 정수가됨을 의미합니다. 예를 들어 SQL Server는 나누기 이후의 나머지 값만 반환합니다. 값이 십진수이면 결과는 십진수가됩니다.

##​ The WHERE clause

SELECT를 제외하고 연산자를 접하게되는 가장 일반적인 위치는 WHERE 절입니다. WHERE 절을 사용하면 쿼리에 특정 조건을 추가 할 수 있습니다. WHERE를 사용하면 조건을 충족하는 데이터 만 결과 집합에 표시되도록 쿼리 결과를 제한 할 수 있습니다. 필터링 할 수있는 몇 가지 일반적인 데이터 유형에는 숫자, 텍스트 및 날짜가 있습니다. 특정 데이터를 반환하도록 레코드를 필터링하기 위해 연산자와 함께 WHERE 절을 사용합니다.

다음 예에서 가상의 sTunes 회사의 영업 부서가 "각각 $ 0.99에 두 곡을 구입 한 고객은 몇 명입니까?"와 같은 질문을한다고 가정 해 보겠습니다. 그 질문에 어떻게 대답할까요? 3 장 데이터 분석 체크 포인트에서 트랙 테이블을 살펴 보았습니다. 그림 43에서 볼 수 있듯이 우리 회사는 $ 0.99 및 $ 1.99에 개별 노래를 판매하는 것을 확인했습니다.

그림 44와 같이 청구서 테이블을 보면 Total 필드에서 고객 주문의 총 가격을 볼 수 있습니다.

$ 0.99 노래 두 개만 구입 한 고객 수를 확인하려면 송장 테이블에서 총 $ 1.98 (두 노래를 나타냄)을 찾습니다.

지난 장에서 배운 도구를 사용하여 모든 송장을 선택한 다음 합계를 기준으로 정렬하는 쿼리를 작성할 수 있지만 수동으로 계산해야합니다. 대신 FROM 및 ORDER BY 절 사이에 WHERE 절을 삽입하여 $ 1.98에 해당하는 합계 만 검색 할 수 있습니다. 합계와 함께 송장 날짜 및 주소와 같은 몇 가지 다른 필드를 추가하면 각 송장을 식별하는 데 도움이됩니다. 이 모든 절을 추가하면 다음이 생성됩니다.

비교 연산자를 사용하여 다음 쿼리를 시도하십시오.
»1.98보다 큰 모든 송장을 반환하는 쿼리를 작성합니다.
»1.98보다 크거나 같은 모든 송장을 반환하는 쿼리를 작성합니다.
 »1.98이 아닌 모든 송장을 반환하는 쿼리를 작성합니다.
논리 연산자도 매우 유용합니다. 비교 연산자로 수행하기 어려운 더 복잡하고 구체적인 쿼리를 작성하는 데 도움이 될 수 있습니다. $ 1.98에서 $ 5.00 사이와 같이 특정 범위 내에 존재하는 인보이스 수를 확인하라는 요청을 받았다고 가정 해 보겠습니다. 이를 수행하는 좋은 방법은 BETWEEN 연산자를 사용하는 것입니다. BETWEEN 연산자는 값 범위를 반환합니다. AND 연산자는 BETWEEN 연산자와 함께 사용되어 결과 집합에서보고자하는 값 범위를 확장합니다. 아래의 예는 1.98에서 5.00 사이의 송장 범위를 반환합니다.

이 쿼리의 처음 10 개 결과 (그림 46)에서 볼 수 있듯이 데이터 세트에 반환 된 송장 총액은 모두 $ 1.98에서 $ 5.00 사이입니다. BETWEEN 연산자는 사용자가 제공하는 매개 변수를 포함합니다. 즉, 이전 예에서는 1.98 및 5.00과 같은 값을 포함합니다. 비교 연산자를 사용하면 WHERE 문에 Total> = 1.98 AND Total <= 5.00을 작성하여 동일한 효과를 얻을 수 있지만 BETWEEN이 더 간단합니다.

앞의 예에서 BETWEEN과 함께 AND 연산자를 사용하고 있지만 AND 연산자는 논리 연산자로서 훨씬 더 광범위한 역할을하며이 장의 뒷부분에서 다룰 것입니다.

»Total 필드를 기준으로 이전 쿼리를 정렬합니다. 이 데이터 세트에서 가장 높은 송장 금액은 얼마입니까?
또 다른 유용한 연산자는 정확한 값 목록을 찾는 데 사용되는 IN 연산자입니다. 이전 예에서 BETWEEN 연산자는 송장 테이블에서 1.98과 5.00 사이에있는 모든 값을 반환했습니다. IN 연산자를 사용하면 데이터 세트 내에서 특정 값을 찾을 수 있습니다. 값은 쉼표로 구분되고 괄호로 묶여 있습니다. 이 쿼리는 정확히 $ 1.98 또는 $ 3.96 인 송장 금액 만 반환합니다 (그림 47).

= 연산자를 사용하면 하나의 값만 찾을 수 있습니다. IN 연산자를 사용하면 필요한만큼 쉼표로 구분 된 값을 추가 할 수 있습니다. 다음 섹션에서 볼 수 있듯이 텍스트와 함께 IN 연산자를 사용할 수도 있습니다.


##​ Searching for text using wildcard values

또한 연산자를 사용하여 숫자로 수행 한 것과 유사한 방식으로 특정 텍스트를 반환 할 수 있습니다. 비교 연산자가있는 예를 살펴 보겠습니다. 다음 질문에 답할 것입니다. Tucson에 청구 된 송장은 몇 개입니까? 이 질문에 답하기 위해 인보이스 합계에 대해했던 것처럼 SELECT 문을 구성합니다. 단, 이번에는 WHERE 절에서 청구 도시에 초점을 맞출 것입니다. 다음 쿼리는 Tucson시에서 청구 된 모든 송장을 반환합니다.
WHERE 절의 기준으로 텍스트를 사용할 때 지정하는 텍스트 값은 작은 따옴표로 묶어야합니다 (BillingCity = 'Tucson').
하나의 값을 찾고 있기 때문에 앞의 예에서 =를 사용하고 있습니다. 여러 도시를 검색하려는 경우 숫자 값을 검색하는 데 사용한 것과 유사한 IN 연산자를 사용할 수 있습니다.

이전 예에서는 = 연산자를 사용하여 찾고있는 텍스트를 정확히 검색했습니다. SQL을 사용하면 LIKE 연산자를 사용하여 텍스트 값의 일부를 검색 할 수도 있습니다. 이것은 데이터베이스에서 텍스트 값의 철자가 확실하지 않을 때 특히 유용합니다. 또한 데이터베이스에서 텍스트 값의 철자가 올바르지 않은 경우가있을 수 있습니다. T로 시작하는 도시에서 청구 된 모든 인보이스를 찾으려면 이러한 유형의 검색을 수용하도록 WHERE 절의 기준을 변경해야합니다.

LIKE 연산자를 유용하게 만드는 이유는 백분율 기호라고도하는 "%"로 표시되는 와일드 카드 문자를 사용하기 때문입니다. = 기호 뒤에 오는 것은 결과 집합에서 볼 수있는 유일한 값입니다. LIKE 및 와일드 카드를 사용하면 입력에 대한 변형을 찾을 수 있습니다. 와일드 카드 문자는 항상 작은 따옴표로 묶입니다. 따옴표가없는 %는 연산자 표의이 장 앞부분에 표시된 것처럼 모듈로라고하는 산술 연산자입니다. 텍스트 검색은 대소 문자를 구분하지 않습니다. 소문자 t와 대문자 T는 동일한 결과를 반환합니다.

와일드 카드 기호는 모든 유형의 문자를 원하는만큼 나타냅니다. 아래 예에서 사용 된 것처럼 쿼리는 T로 시작하는 도시에서 청구 된 모든 인보이스를 검색합니다. 결과에 따르면 이제 Toronto와 Tucson이 모두 포함됩니다. 선택 InvoiceDate, BillingAddress, BillingCity, 총계 청구서에서 BillingCity LIKE 'T %'총계 주문

T 앞에 다른 퍼센트 기호를 추가하면 청구 도시에 T가있는 송장으로 검색이 변경됩니다.

와일드 카드에 대해 생각하는 좋은 방법은 % 기호를 "기타"로 취급하는 것입니다. 예를 들어, '% T %'를 지정하면 "첫 번째 또는 마지막 위치에 있지 않은 텍스트 문자열 어딘가에 T가있는 한 앞뒤에 오는 내용은 신경 쓰지 않습니다. ”

##​ The DATE() function

숫자와 텍스트 모두에 대해 배운 내용을 바탕으로 특정 날짜의 송장을 검색 할 수도 있습니다. 다음 예를보십시오.

우리가 날짜를 기록한 방식을 주목하십시오. 날짜를 쿼리 할 때 먼저 쿼리하는 테이블에 날짜가 저장되는 방식을 살펴 보는 것이 중요합니다. 1 장에서 배운 것처럼이를 위해 데이터 찾아보기 탭을 방문하여 송장 테이블을 선택하고 InvoiceDate 열에 날짜가 저장되는 형식을 관찰합니다. 샘플 데이터베이스에서 날짜는 yyyy-mm-dd 00:00:00으로 저장됩니다. 다음으로 데이터베이스 구조 탭으로 이동하여 청구서 테이블의 InvoiceDate 필드를 살펴 보겠습니다. 유형 열에서이 필드가 DATETIME이라는 데이터 유형으로 날짜를 저장하는 것을 볼 수 있습니다.

WHERE 절에서 사용되는 경우 날짜는 텍스트와 같이 작은 따옴표로 묶여 있습니다. 날짜로 쿼리 할 때 숫자로 쿼리 할 때 사용되는 동일한 연산자 (=,>, <, BETWEEN 등)를 사용하십시오.

SQL에서 날짜로 작업 할 때 관심있는 날짜의 일부를 지정하여보다 세분화 된 결과를 얻는 데 도움이되는 여러 함수에 액세스 할 수 있습니다. 이전 예제에서 송장 테이블의 InvoiceDate 열이 다음과 같이 정의 된 것을 보았습니다. DATETIME 데이터 유형. 따라서 WHERE 절에 날짜 값을 지정할 때 시간 부분 (2009-01-03 00:00:00)을 포함해야했습니다. DATE () 함수를 사용하면 날짜 기준을 지정할 때 시간을 제외 할 수 있습니다.

이 쿼리의 결과는 이전 쿼리의 결과와 동일합니다. 그러나 DATE () 함수를 사용하면 시간 정보가 비어 있거나 관련이 없을 때 쿼리를 입력하는 데 약간의 시간이 절약됩니다.

SQL에서 사용할 수있는 많은 함수가 있습니다. DATE () 함수는 WHERE 절을 사용하여 날짜별로 레코드를 정렬 할 때 특히 유용합니다. 7 장에서는보다 포괄적 인 방식으로 쿼리에서 다른 함수를 사용하는 방법을 살펴볼 것입니다.

##​ Using OR and AND together

지금까지이 장에서는 연산자를 사용하여 한 필드의 하위 집합을 선택했습니다. 예를 들어 BETWEEN 연산자와 함께 AND 연산자를 사용하여 Total 필드의 결과를 두 개의 다른 숫자 값으로 필터링했습니다. AND 및 OR 연산자를 사용하여 여러 필드의 기준을 지정할 수도 있습니다. 아래 쿼리는 DATE 함수와 함께 AND를 사용하여 총 금액이 $ 3.00 미만인 2010-01-02 이후의 모든 송장을 찾습니다. 이 쿼리의 결과는 (DATE (InvoiceDate)> '2010-01-02'AND Total <3) 두 조건을 모두 충족해야합니다.

OR 연산자를 사용하면 요청한 기준과 일치하는 레코드를 찾을 수 있습니다. 다음 쿼리는 청구 도시가 P로 시작하거나 D로 시작하는 모든 송장을 검색합니다.

여러 논리 연산자를 포함하는 더 긴 WHERE 절을 작성할 때 SQL은 기본 산술에 사용되는 것과 유사한 작업 순서를 따릅니다. 미국에 거주하는 경우 PEMDAS (괄호, 지수, 곱셈 / 나눗셈, 더하기 / 빼기)라는 약어를 들어 보셨을 수도 있고 영국의 영향을 더 많이받는 국가에 거주하는 경우 BEMDAS (대괄호, 지수 등)를 들어 보셨을 것입니다. . 둘 다 들어 본 적이 없더라도 걱정하지 마십시오. 연산 순서를 처리하는 간단한 방법이 있지만 지금은 명령문이 AND 연산자와 OR 연산자 모두에서 어떻게 작동하는지 살펴 보겠습니다. 이름이 P 또는 D로 시작하는 도시에서 1.98 달러가 넘는 모든 인보이스를보고 싶다고 가정 해 보겠습니다. 다음과 같이 작성할 수 있습니다.

작성된이 쿼리에 약간의 문제가 있습니다. 쿼리가 실행되면 SQL 브라우저는 먼저 AND 연산자의 양쪽에서 즉시 두 조건을 결합하여 합계가 $ 1.98보다 크고 청구 도시가 P로 시작하는 송장에 대한 결과를 반환 한 다음 오른쪽의 조건을 처리합니다. OR 연산자는 마치 AND가 존재하지 않는 것처럼 완전히 별개입니다. 즉, 먼저 Total> 1.98 AND BillingCity LIKE 'p %'인 결과를 찾은 다음 BillingCity LIKE 'd %'인 모든 결과를 찾은 다음 합계에 따라 오름차순으로 결과를 반환합니다.

위 쿼리를 SQL 브라우저에 입력 한 경우 $ 1.98 미만의 결과가 D로 시작하는 도시에 대해서만 표시됩니다. 이는 SQL 연산 순서에서 AND 연산자가 먼저 처리되고 OR는 두 번째로 처리됩니다. 이 결과는 우리가 원래 원했던 것과 정확히 일치하지는 않지만 SQL 브라우저가 논리 테이블에 의존하지 않고도 우리가 의도 한 방식으로 쿼리를 처리하도록하는 쉬운 방법이 있습니다.

아래 예와 같이 괄호가 추가되면 SQL 브라우저는 먼저 괄호 사이의 기준을 충족하는 모든 레코드를 찾습니다. (BillingCity LIKE 'p %'OR BillingCity LIKE 'd %'). 그런 다음이 레코드 내에서만 합계가 $ 1.98 (총계> 1.98)보다 큰 레코드를 찾습니다.

이 방법으로 쿼리를 작성하면 처음에 원했던 P 도시 또는 D 도시에서 $ 1.98보다 큰 모든 송장 합계가 반환됩니다.

SQL이 논리 연산자를 처리하는 방법을 아는 것이 좋지만 여러 연산자를 사용할 때마다 괄호 만 사용하여 사용자와 코드를 읽는 다른 사람이 실제로 의도 한 바를 명확하게하는 것이 좋습니다. 더 많은 연습을 원하면 괄호가 있거나없는 다음 연습을 시도하여 결과에 어떤 영향을 미치는지 확인하십시오.


##​ The CASE statement

CASE 문을 사용하면 고유 한 사용자 지정 조건을 기반으로 데이터에 대한 레이블 역할을하는 데이터베이스에 새 임시 필드를 만들 수 있습니다. CASE 문의 유용성을 더 잘 이해하려면 가상 회사 sTunes의 다음 시나리오를 고려하십시오.

Operational Scenario 

STunes 영업팀은 새로운 영업 목표를 가지고 있습니다. 그들은 STunes 온라인 스토어에서 음악을 구매할 때 가능한 한 많은 STunes 고객이 7 ~ 15 달러를 지출하기를 원합니다. 따라서 그들은 기본 구매, 낮은 구매, 목표 구매 및 최고 성과 자 카테고리를 만들었습니다.
노래 비용이 $ 0.99에서 $ 1.99 사이이므로이 범위의 모든 인보이스 총액은 기본 구매로 간주됩니다. $ 2.00에서 $ 6.99 사이의 송장 총액은 Low Purchase로 표시됩니다. 목표 판매 목표가 $ 7.00에서 $ 15.00 사이이므로이 카테고리의 모든 판매는 Target Purchase로 레이블이 지정됩니다. $ 15.00 이상의 모든 판매는 최고 성과 자로 간주됩니다.
이러한 카테고리를 기반으로 sTunes 영업 부서는 나열된 모든 카테고리의 판매에 관한 정보를 데이터베이스에서 수집 할 수 있는지 확인하려고합니다.
CASE 문을 사용하여 PurchaseType이라는 송장 테이블에 새 필드를 만들 수 있습니다. 이것은 마치 데이터베이스의 다른 필드 인 것처럼 쿼리의 다른 기존 필드와 함께 나타납니다.

CASE 문을 쿼리에 추가하려면 송장 테이블에서 관심이있는 기존 필드가있는 SELECT 문으로 시작해야합니다. 먼저 4 장부터 사용했던 유형과 유사한 간단한 SELECT 문을 만듭니다.

이 첫 번째 예에서는 지역별 판매 목표를 볼 수 있도록 청구 도시별로 결과를 정렬 할 것입니다.

이 쿼리에 CASE 문을 추가하기 위해 모든 기존 필드 뒤에있는 쿼리의 SELECT 부분 하단에 배치합니다. CASE 키워드를 추가 한 다음 END 키워드를 추가합니다. 이 두 키워드 사이에서 조건 테스트를 시작합니다. 각 테스트는 WHEN 키워드로 시작하고 WHERE 절에 추가하는 것과 유사한 논리 테스트가 이어집니다. 테스트 할 첫 번째 사례는 Baseline Purchases이며, 이는 $ 2.00 미만의 송장, 즉 "TOTAL <2.00"입니다. 논리적 조건 다음에 해당 조건이 충족 될 경우 발생하려는 작업을 지정합니다. 이것은 THEN 키워드로 수행됩니다. $ 2.00 미만의 케이스에 대해 우리가 원하는 라벨은 운영 시나리오에 지정된 '기준 구매'입니다.

이 동일한 순서는 우리가 테스트하려는 많은 조건에 대해 반복 될 수 있습니다. 따라서 운영 시나리오에 언급 된 나머지 판매 범주에 대해이 프로세스를 반복합니다. ELSE 키워드는 항상 나열된 마지막 명시 적 조건을 따릅니다. 아직 분류되지 않은 모든 레코드는 ELSE 절에 명명 된 범주에서 할당됩니다.

ELSE 키워드는 포함 할 필요는 없지만 포함하는 것이 좋습니다. 데이터에 조건을 벗어난 이상 값이있을 수 있습니다. ELSE 절은 이러한 이상 값을 캡처하고이를 사용하여 수행 할 작업을 파악할 수 있습니다. ELSE 절을 포함하지 않으면 조건을 벗어나는 데이터 세트의 모든 결과가 NULL로 반환됩니다.

마지막으로 할 일은 데이터베이스에서 새 필드의 이름이 될 별칭을 만드는 것입니다. 이 별칭은 END 문 뒤에옵니다. 새 필드를 PurchaseType이라고 부를 것입니다.

AS 키워드를 사용하여 별칭을 만듭니다. 따라서 CASE 문은 END AS와 테이블의 새 필드에 대해 선택한 별칭 이름으로 종료됩니다.

ORDER BY 절을 사용하여 생성 한 새 필드를 기준으로 결과를 정렬 할 수도 있습니다.이 필드는 각 구매 유형 카테고리를 알파벳순으로 표시하며 '기준 구매'로 시작하고 '최고 성과 자'로 끝납니다. 명확성을 위해 구매 가격 상승과 일치하도록 이러한 범주의 이름을 편리하게 지정했지만 원하는대로 이름을 지정할 수 있습니다.

이제 데이터에 대한 새 범주를 만들었으므로 나머지 SELECT 문을 조작하여 새 판매 범주를 기반으로 한 고객의 인구 통계에 대해 자세히 알아볼 수있는 유용한 방법이 많이 있습니다. 우리의 사례 진술이 작성되었으므로 다음과 같은 몇 가지 관련 질문에 답할 수 있습니다.

»최고의 매출이 발생하는 도시는 어디입니까?
»주로 미국 또는 세계의 다른 지역에서 가장 실적이 좋은 매출입니까?
»가장 기본적인 구매가 이루어진 도시는 어디입니까?

첫 번째 질문을 자세히 살펴 보겠습니다. WHERE 절을 사용하여 기존 쿼리를 수정하여 최고 성과자만 보고 도시별로 정렬 할 수 있습니다.

이 쿼리의 결과를 살펴보면 상위 성과 기업이 주로 미국 이외 지역에서 온다는 것을 알 수 있습니다. 검색하거나 좁힐 수있는 필드 조합은 사실상 무한합니다. 예를 들어, 계절별 구매 추세가 있는지 확인하기 위해 송장 날짜별로 데이터를 구성 할 수도 있습니다. 이 장에서 배운 WHERE 절 및 연산자와 함께 CASE 문을 사용하면 데이터를 영업 팀이 직접 관심을 가질 수있는 정보로 변환 할 수 있습니다.

이 장의 예에서는 표시하려는 필드를 나열한 후 쿼리의 SELECT 부분에서 항상 CASE 문을 사용했습니다. 다가오는 실제 SQL 어드벤처에서 WHERE 절에 CASE 문이 포함 된 쿼리가 발생할 수도 있습니다. 지금 중요한 것은 CASE 문이 SELECT에서 정의되어야하지만 다른 곳에서 참조 될 수 있다는 점을 기억하는 것입니다.

##​ Data Analysis Checkpoint



# Chapter 6. Working with Multiple Tables

지금까지 작성한 모든 쿼리에서 한 번에 하나의 테이블에서만 데이터를 검색했습니다. 몇 가지 강력한 쿼리 방법을 배웠지만 성장하는 SQL 도구 키트에서 관계형 데이터베이스의 힘을 실제로 활용하는 것은 없습니다. sTunes 데이터베이스에는 13 개의 테이블이 있습니다. 각 테이블에는 가상 회사에 대한 정보의 일부가 포함되어 있습니다. sTunes 회사 경영진의보다 복잡한 질문에 답하려면 여러 테이블의 데이터에 동시에 액세스해야합니다. 이 장에서는 조인이라는 강력한 도구를 사용하여 단일 쿼리로 두 개 이상의 테이블에서 데이터를 편안하게 얻을 수 있도록 도와줍니다.

##​ Introducing joins

조인은 관계형 데이터베이스의 두 개 이상의 테이블에서 필드를 결합하는 명령입니다. sTunes 데이터베이스의 청구서 테이블을 사용하는 매우 간단한 예를 살펴 보겠습니다. 이전 장에서 송장 테이블을 광범위하게 사용 했으므로 지금까지는 이 특정 테이블의 필드에 대해 잘 알고 있어야합니다. SQL 브라우저의 Browse Data 탭에서 볼 수 있듯이 (그림 62) 청구서 테이블에는 9 개의 필드가 있습니다. 각 송장에는 InvoiceId라는 식별 번호가 있습니다. 송장을 생성 한 각 고객에게는 CustomerId라는 식별 번호가 있습니다. 송장 테이블에는 송장 날짜 및 송장 합계에 대한 필드도 있습니다. 이 테이블의 나머지 필드는 송장 청구 주소 전용입니다.

STunes 마케팅 부서가 고객 기반에 대해 더 잘 알고 싶어한다고 가정 해 보겠습니다. 그들은 해당 고객이 생성 한 모든 송장 옆에 고객 이름 (이름과 성)의 전체 목록을 요청합니다. 송장 테이블 만 사용하여 이러한 쿼리를 어떻게 작성할 수 있습니까? 지금까지 배운 기술을 사용하여 한 번의 질문으로이 질문에 답할 수 없습니다. 송장 표에는 고객 이름이 포함되어 있지 않습니다. 대신 청구서 테이블에는 CustomerId라는 필드가 있습니다. 송장을 생성 한 고객이 포함 된 송장 목록을 표시하는 방법을 알아 보려면 송장과 고객 테이블을 나란히 살펴보아야합니다.

 참고) 모든 테이블에는 기본 키 역할을하는 필드가 하나 이상 있어야합니다. 한 테이블의 기본 키는 종종 다른 테이블의 외래 키로 존재합니다.
 
CustomerId는 customers 테이블의 기본 키이고 청구서 테이블에 동일한 이름의 유사한 필드가 있으므로이 두 CustomerId 필드는 두 테이블에 동시에 액세스하는 데 필요한 링크를 제공합니다. 이제이 두 테이블을 결합하고 고객 이름이 포함 된 송장 목록을 생성하는 데 필요한 모든 정보를 얻었습니다.
이 두 테이블을 함께 병합하는 JOIN 절은 다음과 같습니다.


NOTE)이 예에서는 INNER JOIN이라는 조인을 사용합니다. 이 장에서는 몇 가지 다른 유형의 조인을 소개합니다. 각 조인은 약간 다른 방식으로 작동합니다. 이러한 차이점은 나중에 다룰 것입니다. 이 시점에서 우리가 알아야 할 것은 조인을 통해 서로 다른 테이블의 필드에 액세스 할 수 있다는 것입니다.

이 쿼리를 보면 우리가 이미 알고있는 것이 많습니다. 지금까지의 모든 쿼리와 마찬가지로 쿼리는 SELECT로 시작됩니다. 이 예에서는 4 장에서 배운 * 기호를 사용하여 테이블의 모든 필드를 반환합니다. 송장 테이블에서 모든 필드를 선택하고 고객 테이블의 모든 필드에 결합합니다. ON 키워드를 사용하여 CustomerId 필드 인이 두 테이블 간의 링크를 쿼리에 제공합니다. CustomerId 필드에는 두 가지 버전 (각 테이블에 하나씩)이 있으므로 SQL 브라우저에 사용할 특정 버전을 알리기 위해 특수 표기법 (tablename.FieldName 형식)을 사용해야합니다. 청구서 테이블 (invoices.CustomerId로 작성)의 CustomerId 필드를 customers 테이블 (customers.CustomerId로 작성)의 CustomerId 필드와 동일하게 설정합니다. 쿼리를 실행하면 결과 출력이 그림 64에 나와 있습니다.

 NOTE) * 기호를 사용하여 총 22 개의 필드에 대해 청구서 테이블의 9 개 필드와 고객 테이블의 13 개 필드를 결합했습니다. 인쇄를 위해 이러한 필드 중 일부를 잘라 냈지만 SQL 실행 탭의 결과 창에있는 가로 스크롤 막대를 사용하여 DB 브라우저에서 22 개 필드를 모두 볼 수 있습니다.
 
 
##​ Joins and relational database structure

송장 테이블과 고객 테이블을 결합한 지금 몇 가지 관찰 할 수 있습니다. 결과 집합의 청구서 섹션에서 InvoiceId 필드를 보면 (그림 64) 처음 7 개 레코드가 동일한 CustomerId에 연결되어 있음을 알 수 있습니다. 이 링크는 고객 번호 1이 해당 송장 7 개를 모두 생성 할 책임이 있음을 알려줍니다. 결과 집합의 customers 테이블 부분을 따라 가면이 고객의 이름이 Luís Gonçalves임을 알 수 있습니다. 한 고객이 여러 송장에 연결되어 있습니다. 관계형 데이터베이스의 언어 (1 장에서 소개됨)로 고객 테이블이 송장 테이블과 일대 다 관계를 가지고 있다고 말할 수 있습니다. 단일 CustomerId를 가진 단일 고객은 여러 곡을 주문하여 많은 송장을 생성 할 수 있지만 송장 테이블에 동일한 CustomerId 번호를 유지합니다. 이 관계를 설명하는 또 다른 방법은 ERD (엔티티 관계 다이어그램)를 사용하여 데이터베이스 스키마를 구성하는 것입니다.

그림 65에서 고객 테이블과 송장 테이블 간의 관계를 그래픽으로 볼 수 있습니다. 나머지 데이터베이스를 살펴보면 서로 다른 테이블 간의 관계를 설정하는 기본 및 외래 키의 다른 많은 인스턴스를 볼 수 있습니다. 조인을 만들고 사용하는 과정 중 일부는 이러한 관계를 이해하는 것입니다. 테이블을 함께 결합하려면 기본 키와 외래 키를 식별하고 선택하려는 필드를 이해할 수 있어야합니다.

송장 테이블에 모든 고객 이름이 포함 된 필드가있는 경우 조인이 필요하지 않습니다. 한 단계 더 나아가서 13 개의 테이블이있는 데이터베이스 대신 모든 필드를 포함하는 하나의 거대한 테이블 만 가질 수 있습니다.

관계형 데이터베이스에서 관련 테이블에 필드를 배포하는 프로세스를 정규화라고합니다. 정규화는 동일한 테이블에 중복 필드가 있어야하는 필요성을 줄이므로 데이터베이스 크기를 더 작게 유지합니다. 데이터베이스 크기가 증가함에 따라 데이터베이스를 정규화해야 할 필요성이 증가합니다. 몇 초의 쿼리 처리 시간도 절약 할 수 있습니다. 일부 데이터베이스의 엄청난 크기를 고려하면 매초가 중요합니다. Google 검색에 몇 초가 아닌 5 분이 걸린다고 상상해보십시오. 이제 청구서 테이블과 고객 테이블 모두에서 두 관련 필드 사이의 공통 링크를 식별 했으므로 조인을 사용하여 쿼리를 작성하는 방법을 자세히 살펴볼 수 있습니다.

##​ Joins and aliases

첫 번째 예에서 필드 이름을 참조 할 때 조인에 특수 구문이 있음을 확인했습니다. 주어진 데이터베이스의 두 테이블에 동일한 이름의 필드가 있을 수 있으므로 조인을 만들 때 특정 필드를 나열 할 때 테이블 이름을 지정하여 SQL 브라우저가 우리가 참조하는 해당 필드의 버전을 정확히 알 수 있도록해야합니다. 이 구문을 사용하려면 먼저 테이블 이름, 마침표, 필드 이름을 차례로 나열해야합니다. 조인은 자주 별칭과 함께 사용되어 필요한 입력량을 줄이고 가독성을 높이기 위해 사용됩니다. 다음 두 조인은 기능면에서 동일합니다.

 NOTE) 조인의 별칭은 규칙에 따라 간결하고 읽을 수 있도록 설계되었습니다. 이러한 별칭은 일반적으로 단일 문자이며 사용 된 문자는 관련 테이블의 첫 번째 문자입니다 (tablename.FieldName은 t.FieldName이 됨). 이 장의 나머지 부분에서는 테이블 이름에 단일 문자 별칭을 사용합니다.

조인으로 작업 할 때 별칭이 필요한지 더 자세히 설명하기 위해이 장의 원래 가상 시나리오로 돌아가 보겠습니다. STunes 경영진은 고객 이름과 각 고객이 생성 한 송장을 보여주는 목록을 원했습니다. 이 장에서 첫 번째 조인을 작성할 때 * 기호를 사용하여 각 테이블에서 모든 필드를 선택했습니다. 이 쿼리는 22 개의 필드로 구성된 방대한 결과 집합을 생성했습니다. 그러나 우리는 고객 이름과 송장 정보에만 관심이 있었습니다. 또한 * 기호를 사용하면 필드가 표시되는 순서를 제어 할 수 없습니다. 예를 들어 sTunes 경영진이 성이 먼저 표시된 고객 목록을 표시하도록 지정했다고 가정 해 보겠습니다. 사용자 정의 된 순서로 출력을 생성하려면 * 기호를 사용하는 대신 SELECT 문에서 개별 필드 이름을 선택해야합니다. 위와 유사한 조인을 생성 해 보겠습니다. 이번에는 customers 테이블의 LastName 및 FirstName 필드와 invoices 테이블의 InvoiceId, CustomerId, InvoiceDate 및 Total을 보려는 쿼리를 지정하겠습니다. 필드 이름이 동일한 일부 필드를 포함하는 두 개의 테이블을 다루기 때문에 SELECT 문에 개별 필드를 나열 할 때 조인의 ON 절에서 사용한 것과 동일한 tablename.FieldName 표기법을 사용해야합니다. 전체 테이블 이름을 나열하는 대신 테이블의 첫 글자와 마침표, 필드 이름으로 구성된 별칭을 사용합니다. 마지막으로 고객의 성을 기준으로 결과를 주문하려고합니다. 결과 쿼리는 다음과 같습니다.

 NOTE) 별칭을 정의하기 전에 (FROM 및 INNER JOIN 문에서) 별칭을 참조하는 것처럼 보이지만 (SELECT 문에서) SQL 브라우저는 우리가 사람이 읽는 것과 똑같은 방식으로 쿼리를 처리하지 않는다는 것을 기억해야합니다. .
 
이 쿼리의 처음 10 개 결과를 보면 * 기호가있는 모든 필드를 반환하는 것보다 특정 필드를 특정 순서로 나열하는 것이 훨씬 더 관리하기 쉽다는 것을 알 수 있습니다. 또한 필드 이름을 참조 할 때마다 테이블 이름을 입력해야 한다면 이 조인이 얼마나 더 복잡할지 상상할 수 있습니다.

  NOTE) 대부분의 경우 select 문에 개별 필드 이름을 지정하고 * 기호를 사용하지 않는 것이 가장 좋습니다. 그러나이 장에서는 JOIN 구조를 설명하기위한 설명 목적으로 만 * 기호를 사용합니다.
  

##​ Inner join, left outer join, and right outer join

이 장의 시작 부분에서 언급했듯이 몇 가지 유형의 조인이 있습니다. 지금까지 여러 테이블의 필드에 대한 액세스를 제공하기 위해 조인을 사용했습니다. 고객 테이블의 기본 키를 식별하고 청구서 테이블에서 유사한 외래 키를 식별했으며 모든 데이터가 일치하기를 바라면서 ON 키워드를 사용하여 두 테이블을 함께 연결했습니다.

Q : 조인하는 테이블의 데이터가 완전히 일치하지 않으면 어떻게됩니까?

예를 들어 고객 (고객 6이라고 부르겠습니다)이 자신의 sTunes 계정을 삭제 한 후 고객 테이블에서 제거 된 경우 어떻게됩니까? sTunes 회사는 재무 기록을 보관해야하므로 청구서 표에는 고객 6이 어느 시점에 구매했다는 증거가 여전히 있습니다. 데이터베이스에서 불일치를 찾는 것은 드문 일이 아니며 일치하지 않는 데이터를 쿼리에 포함할지 또는 완전히 제외할지 여부를 결정해야합니다. 테이블 간의 불일치를 처리하기 위해 다양한 유형의 조인이 사용됩니다. 이 개념을 이해하려면 송장 및 고객 테이블의 약간 단순화 된 버전을 사용하여 추상에서 조인 유형을 살펴 보는 것이 좋습니다.

 참고) 다음 표는 sTunes 데이터베이스의 표와 약간 다릅니다. 우리는 두 테이블의 기본 구조를 sTunes 청구서 및 고객 테이블과 동일하게 유지했지만 테이블을 각각 5 개의 레코드로 줄였고, 일부 필드를 제거하고, 레코드 이름을 단순화하고, 각 테이블에 다른 레코드 몇 개를 추가했습니다. 다른 테이블의 레코드.

단순화 된 송장 및 고객 표를 살펴보면 몇 가지 불일치를 확인할 수 있습니다. 먼저 청구서 표는 고객 ID가 6 인 누군가가 2017 년 5 월 1 일에 구매했지만이 고객은 고객 표에 표시되지 않음을 보여줍니다. 또한 고객 1과 고객 5는 송장 테이블에 표시되지 않기 때문에 구매를 전혀하지 않은 것으로 보입니다. 고객 2가 두 번 표시되므로 해당 고객이 두 번 구매 한 것으로 추론 할 수 있습니다. Customer 1 및 Customer 5에 대한 레코드는 customers 테이블에는 있지만 invoices 테이블에는 존재하지 않고 Customer 6에는 invoices 테이블에만 존재하므로 각 테이블에는 다른 테이블에없는 고유 한 레코드가 하나 이상 포함되어 있습니다. 이제이 두 테이블을 함께 조인하고 어떤 조인 유형을 사용하는지에 따라 출력이 어떻게 처리되는지 관찰 할 수 있습니다. 익숙한 내부 조인부터 시작하겠습니다.


### The Inner Join 

내부 조인은 일치하는 레코드 만 반환합니다. 두 테이블에서 일치하지 않는 데이터는 무시됩니다. 조인은 그림 68과 같이 종종 벤 다이어그램으로 설명됩니다. 내부 조인은 벤 다이어그램의 겹치는 섹션 만 나타냅니다.

이 예에서 내부 조인은 청구서 테이블에서 청구서 5를 무시합니다.이 청구서는 고객 테이블에 나타나지 않는 고객 (고객 6)을 참조하기 때문입니다. 마찬가지로 Customers 테이블의 Customers 1과 5는 송장을 생성하지 않았으므로 해당 레코드도 무시됩니다. 벤 다이어그램에서 볼 수 있듯이 겹치는 데이터 만 포함됩니다. 그림 69는 서로 다른 데이터가있는 두 테이블에서 내부 조인이 생성되는 방식을 시각적으로 나타낸 것입니다.

이 장의 앞부분에서 배운 것처럼 CustomerId 필드는 청구서 테이블과 일대 다 관계를 갖습니다. 이 데이터가 일치하지 않는 것처럼 보일 수 있지만 결과 집합은 4 개의 레코드를 반환합니다. 이 결과는 고객 2가 두 개의 개별 송장을 생성했기 때문에 발생합니다.

이 내부 조인의 SQL 코드는 첫 번째 예제의 코드와 유사합니다. 먼저 적절한 별칭을 포함하도록주의하면서 SELECT 문에 표시 할 필드를 나열합니다.

 NOTE) 내부 조인은 일치하는 데이터 만 반환하므로 테이블이 나열되는 순서는 중요하지 않습니다. 다른 조인 유형의 경우 순서가 중요합니다.

이 쿼리의 출력에서 ​​4 개의 레코드 만 반환되었음을 알 수 있습니다. 송장 5, 고객 1 및 고객 5는 생략됩니다. 고객 2는 두 개의 레코드를 담당합니다. 내부 조인은 가장 일반적인 조인 유형입니다. 내부 조인의 주요 용도는 관계형 데이터베이스의 다른 테이블에서 해당 데이터를 함께 가져 오는 것입니다.

 NOTE) 키워드 "inner"는 내부 조인에서 선택 사항입니다. 달리 지정하지 않는 한 모든 조인은 내부 조인으로 해석됩니다. 즉, 조인은 기본적으로 내부입니다.


### The Left Outer Join 

왼쪽 외부 조인은 왼쪽 테이블의 모든 레코드를 오른쪽 테이블의 일치하는 레코드와 결합합니다. 이 유형의 조인에 해당하는 벤 다이어그램이 그림 71에 나와 있습니다.

 NOTE) "왼쪽 테이블"과 "오른쪽 테이블"의 개념은 전적으로 이러한 테이블이 JOIN 문에 나열된 순서에 따라 달라집니다. 목록 순서를 전환하면 다른 결과 집합이 생성됩니다. 이 구분은이 장의 뒷부분에서 왼쪽 조인을 오른쪽 조인으로 변환 할 때 중요합니다.
 
이 유형의 조인을 사용하면 송장 테이블의 모든 항목이 표시됩니다. 고객 1은 노래를 주문하지 않았으므로 해당 특정 레코드는 생략됩니다. 그러나 그림 72에서 볼 수 있듯이 청구서 테이블의 5 개 레코드를 모두 고객 테이블의 4 개 레코드와 결합합니다. (인보이스 테이블에 Customers 1 또는 5에 대한 레코드가없고 Customer 2가 두 개의 인보이스를 생성했습니다.) 각 테이블에서 동일한 수의 레코드와 일치하는 내부 조인과 달리 왼쪽 외부 조인은 다음에서 더 많은 레코드를 반환 할 수 있습니다. "왼쪽"테이블. SQL 브라우저가이를 처리하는 방법을 이해하려면이 쿼리의 출력을 확인해야합니다.

왼쪽 외부 조인에 대한 SQL 쿼리는 내부 조인에 사용한 것과 매우 유사합니다. 대신 LEFT OUTER JOIN을 사용합니다.


 NOTE) 왼쪽 외부 조인의 경우 "outer"키워드는 선택 사항입니다.
왼쪽 조인의 출력을 보면 SQL 브라우저가 결과 집합에 null 데이터를 추가했음을 알 수 있습니다. 고객 테이블에는 고객 6에 대한 정보가 없다는 것을 기억하십시오. 널 데이터를 추가하면 SQL 브라우저가 송장의 5 개 레코드를 고객의 4 개 레코드에만 일치 시키려고한다는 사실을 처리하는 방법입니다. 왼쪽 조인은 데이터의 불일치를 볼 수 있기 때문에 유용합니다. 송장을 생성하지 않은 고객 목록을 생성하거나 오른쪽 테이블에서 제거되었지만 여전히 왼쪽 테이블에 존재하는 데이터를 검색 할 수 있습니다.

### The Right Outer Join 

오른쪽 외부 조인은 SQLite에서 지원되지 않지만 오른쪽 조인은 다른 RDBMS 구현에서 여전히 널리 사용되므로 어쨌든 포함 할 것입니다. 왼쪽 조인에 대한 논의에서 언급했듯이 나중에 SQLite에서 오른쪽 조인을 사용하기위한 해결 방법을 제시합니다.

오른쪽 외부 조인은 전체 오른쪽 테이블과 왼쪽 테이블에서 일치하는 정보를 반환합니다. 오른쪽 조인은 왼쪽 조인의 미러 이미지이며 매우 유사한 방식으로 작동합니다.

왼쪽 조인에서 발생한 것과 유사하게 오른쪽 조인은 오른쪽 (고객) 테이블의 모든 필드를 가져 와서 해당 데이터를 송장 테이블의 해당 데이터와 일치시킵니다. Customer 6이 customers 테이블에 없기 때문에이 레코드는 무시됩니다. 올바른 조인을 생성하는 데 필요한 SQL 문은 지금까지 살펴본 다른 두 조인과 유사합니다.

 참고) 왼쪽 외부 조인과 마찬가지로 "outer"키워드는 선택 사항입니다. RIGHT JOIN을 작성하면 동일한 결과가 생성됩니다.

이 특정 조인은 지금까지 시연 한 세 가지 조인 중 가장 많은 레코드를 반환했습니다. 고객 1과 5는 청구서 테이블에 해당 데이터가 없으므로 해당 레코드에 null 값이 할당되었습니다. 송장 테이블의 두 레코드가 고객 2에 해당하므로 조인으로 인해 고객 2의 데이터가 두 번 나열되었습니다. 오른쪽 조인은 왼쪽 조인보다 덜 자주 사용됩니다. SQLite는 올바른 조인을 인식하지 못하기 때문에 쿼리에서 테이블 순서를 바꾸는 것이 가장 좋습니다. 그러면 동일한 결과 집합이 생성됩니다. 이것은 장 뒷부분에서 설명합니다.

 NOTE) 
 
 
##​ Joining more than two tables

조인은 두 개 이상의 테이블을 결합 할 수 있습니다. 조인을 사용하여 추가 테이블을 추가하는 것은 간단합니다. 이미 시연 한 내부 조인과 동일한 패턴을 따릅니다. 그림 77의 데이터베이스 스키마를 살펴보십시오. 송장과 고객 테이블 간의 관계 외에도 SupportRepId 필드 (고객 테이블에서)와 EmployeeId 필드 (직원에서 제공)간에 관계가 있음을 알 수 있습니다. 표).

지금까지 ON 키워드를 사용하여 서로 관련시킨 두 필드의 이름은 동일했습니다. 이 경우 엔터티 관계 다이어그램에 해당 필드가 있음을 보여 주지만 두 필드를 서로 다른 이름으로 연결합니다. 왜 이런 일이 발생합니까? 이러한 불일치는 관계형 데이터베이스 구조에 대한 중요한 교훈을 알려줍니다. 두 개의 해당 필드가 같은 이름을 가질 필요는 없습니다. 실제로이 두 필드가 다른 이름을 갖는 데에는 좋은 이유가 있습니다. sTunes 회사에서는 각 고객에게 SupportRepId 또는 개인 회사 담당자가 할당됩니다. 모든 고객 지원 담당자에게 할당 된 번호는 직원 테이블의 직원 번호에 사용 된 것과 동일한 번호입니다. 이 데이터베이스의 작성자는 두 필드의 이름을 EmployeeId로 지정할 수 있지만이 전략으로 인해 혼란이 발생할 수 있습니다. 고객에게는 지원 담당자가 있고 SupportRepId 번호가 EmployeeId 번호와 동일하다는 것이 합리적이지만 고객 테이블에 EmployeeId 필드가 있으면 혼동을 일으킬 수 있습니다. 동일한 데이터를 나타내는 두 이름은 각 테이블 내의 데이터에 대해 다른 역할을 의미합니다. 고객에서 필드 SupportRepId의 이름을 지정하면 고객 테이블과 관련하여이 필드의 목적이 무엇인지 즉시 알 수 있습니다. EmployeeId에 대해 다른 숫자 시스템을 만드는 대신 관계형 데이터베이스 구조의 힘을 통해 두 시스템을 연결할 수 있으며이 연결은 데이터베이스 스키마에 표시됩니다 (그림 77).

이제 송장, 고객 및 직원 테이블을 연결하는 방법을 이해 했으므로 "이유"를 찾아야합니다. STunes 고객 서비스 부서가 10 대 개인 판매를 담당하는 직원에게 보상을 원한다고 가정 해 보겠습니다. 고객 서비스는 각 직원이 도움을 준 고객 목록이 포함 된 명판을 만들고 싶어합니다.

이제 운영 시나리오가 있으므로 ERD를 살펴보고 쿼리에 필요한 필드를 결정할 수 있습니다. 때로는 여러 테이블에 액세스하는 복잡한 쿼리를 작성할 때 필요한 필드와 해당 필드의 출처를 생각하는 것이 도움이됩니다 (그림 78). 이제 표시 할 필드에 대한 아이디어를 얻었으므로 쿼리 작성을 시작할 수 있습니다. FROM 절의 송장부터 시작하겠습니다. 그런 다음 두 개의 INNER JOIN 절을 순차적으로 작성합니다. 하나는 송장을 고객에게 조인하고 다른 하나는 송장과 고객을 직원에게 조인합니다. 전체 쿼리를 송장 합계별로 정렬합니다 (가장 높은 합계를 먼저 보려면 내림차순).

이제 가장 높은 송장 총액을 담당하는 sTunes 직원 목록이 있습니다. 이 결과 집합에 대해 관찰 할 수있는 몇 가지 사항이 있습니다. 예상 한대로 customers 테이블과 직원 테이블을 연결하는 데 사용하는 필드에는 두 가지 이름이 있지만 데이터는 명확하게 일치합니다. SupportRepId의 숫자 값은 EmployeeId 필드의 값과 동일합니다.


### Using Left Outer Joins with NULL, IS, and NOT 

이 장의 앞부분에서 보았 듯이 왼쪽 외부 조인은 왼쪽 테이블의 모든 항목과 오른쪽 테이블의 모든 일치 정보를 보여줍니다. 이 기능은 데이터베이스를 분석하고 불완전한 정보를 확인하는 데 유용합니다. STunes 회사가 앨범과 단일 곡을 분류하는 방식에 대해 내부 감사를 실시하고 있다고 가정 해 보겠습니다. STunes 경영진은 앨범이없는 모든 아티스트의 목록을 생성하도록 요청합니다. 앞의 엔터티 관계 다이어그램을 보면 우리가 집중하고있는 정보가 아티스트 및 앨범 테이블에 저장 될 것이라고 추측 할 수 있습니다. 이러한 테이블 간의 관계를 살펴 보겠습니다.

그림 80에서 볼 수 있듯이 우리의 artist 테이블은 기본 키인 ArtistId 필드와 아티스트 이름에 대한 필드로 구성됩니다. ERD에서 Artist 테이블이 albums 테이블과 일대 다 관계를 가지고 있음을 알 수 있습니다. 아티스트가 많은 앨범을 생성 할 수 있기 때문에이 관계는 의미가 있습니다. albums 테이블에는 자체 기본 키인 AlbumId와 외래 키 역할을하는 ArtistId 필드가 있습니다.

artist 테이블이 왼쪽 테이블 인 LEFT OUTER JOIN은 albums 테이블에서 일치하는 레코드 (사용 가능한 경우)와 함께 Artist 테이블의 모든 데이터를 반환합니다. 왼쪽 조인은 null 값이있는 앨범 제목이없는 모든 필드를 채 웁니다. 이제 명확한 계획이 있으므로 쿼리 작성을 시작할 수 있습니다. 이 장에서는 테이블의 첫 글자를 대부분의 조인에 대한 별칭으로 사용했습니다. 첫 글자가 같은 두 개의 테이블이 있으므로이 쿼리에서는 각각 두 글자를 사용합니다.


##​ Data Analysis Checkpoint
 








# | 10 | DATA MANIPULATION LANGUAGE (DML) 

지금까지 우리가 제시한 모든 SQL 문은 데이터베이스에서 데이터를 검색하거나 기존 데이터베이스 값을 기반으로 파생 데이터를 생성하는 방식으로 사용되었습니다. 이 장에서는 데이터 조작 언어(DML)를 소개하고 데이터베이스의 테이블에 저장된 데이터를 변경하거나 변경하는 데 사용되는 SQL 문을 검사합니다.

제공된 샘플 데이터베이스와 같은 샌드박스 공간에서 이러한 명령을 연습하는 것이 가장 좋습니다. 활성 고객 데이터가 있는 라이브 데이터베이스에서 DML을 사용하면 영구적으로 해로운 영향을 미칠 수 있습니다.

## Data Analysis Versus Database Management 

지금까지 이 책에서 SQL 쿼리의 주요 목적은 데이터베이스의 기존 데이터를 가져와 sTunes 회사의 가상 이해 관계자에게 유용한 실행 가능한 정보로 바꾸는 것이었습니다. 그러나 서론에서 언급했듯이 SQL의 기능은 데이터를 의미 있는 정보로 바꾸는 작업을 훨씬 능가합니다. 회사 데이터베이스의 성장, 개선 및 관리를 감독하는 데이터베이스 개발자 및 데이터베이스 관리자와 같은 역할이 있습니다. 이러한 역할의 범위와 범위는 회사와 데이터베이스 구현에 따라 다릅니다. 숙련된 SQL 사용자들 사이에서도 DML이 별도의 연구 분야인지, 아니면 정보만 추출하도록 설계된 SQL 문과 함께 배워야 하는지에 대해 의견이 분분하다.

> 다양한 데이터베이스 역할은 초보자에게 혼란을 줄 수 있습니다. DML은 데이터베이스 관리 및 개발 범주에 딱 들어맞지만 데이터베이스가 하나만 있는 소규모 회사에서는 데이터 분석가, 개발자 및 관리자의 역할이 모두 한 사람에게 할당될 수 있으며 그 사람이 바로 귀하일 수도 있습니다! 따라서 주요 목표가 유용한 선택 쿼리를 작성하는 방법을 배우는 것이더라도 최소한 DML이 작동하는 방식을 이해하는 것은 가치가 있습니다.

이 장의 목적을 위해 DML(데이터 조작 언어)이라고 하는 명령문은 INSERT, UPDATE 및 DELETE입니다. 이름에서 알 수 있듯이 이러한 명령문을 사용하여 데이터베이스의 테이블에서 데이터를 추가, 수정 및 제거할 수 있습니다. sTunes 운영 시나리오의 경우 기존 음악 서비스에 아티스트를 추가하고 새 레코드를 추가한 다음 해당 레코드를 삭제하라는 sTunes 관리 요청을 처리하는 방법을 보여줍니다.

> DB 브라우저에서 DML을 사용하여 sTunes 데이터베이스를 변경하면 프로그램을 종료하거나 데이터베이스 파일을 닫을 때 변경 사항을 저장할 것인지 묻는 메시지가 프로그램에 표시됩니다. 원본 데이터베이스 파일의 복사본을 만들어 이러한 수정 사항을 연습하고 저장하고 원본을 계속 유지할 수 있습니다.


## Inserting Data into a Database 

INSERT 문은 한 번에 한 행씩 테이블에 데이터를 삽입하는 데 사용됩니다. INSERT 문을 구성하는 몇 가지 방법이 있습니다. 한 가지 방법은 INSERT INTO를 사용하고 원하는 필드를 지정하는 것입니다. sTunes 회사가 음악 선택을 확장하고 있으며 아티스트 테이블에 아티스트를 추가하기를 원한다고 가정해 보겠습니다. 다음 INSERT 문은 아티스트 테이블에 새 레코드를 삽입합니다.

INSERT INTO
artists (Name)
VALUES ('Bob Marley')    

이 삽입에는 테이블, 필드 및 값의 세 가지 요소가 있습니다. 테이블 아티스트는 INSERT INTO 키워드 뒤에 지정됩니다. 수정하려는 테이블을 식별합니다. 그 뒤에 괄호()로 묶인 필드 이름이 옵니다. 이 경우 이름 필드에 아티스트의 이름을 추가하여 새 아티스트를 추가하려고 합니다. 그런 다음 VALUES 키워드가 옵니다. 여기에서 여는 괄호와 닫는 괄호가 아티스트 테이블에 삽입되는 실제 값을 묶습니다. 이 예에서 값은 Bob Marley입니다. "Bob Marley"는 텍스트 값이므로 작은따옴표로 묶습니다.

데이터베이스 구조 탭에서 아티스트 테이블의 이름 필드 데이터 유형을 확인할 수 있습니다. 데이터 유형은 NVARCHAR(120)이며, 이는 예상 제한이 120자인 문자 데이터 유형입니다.

ON YOUR OWN:
 » 위의 INSERT 문을 실행한 결과는 무엇입니까?
 » 새로 삽입된 값을 찾는 SELECT 문을 작성합니다.
 » "Peter Tosh" 값을 아티스트 테이블에 삽입합니다.
 » 새로 추가된 Bob Marley 레코드의 ArtistId 값은 무엇입니까?

ArtistId라는 Artists 테이블에 두 번째 열이 있습니다. 이 열은 Auto Increment 열이기 때문에 INSERT 문에서 지정할 필요가 없습니다. 즉, 추가되는 새 레코드의 열에 새 번호가 자동으로 생성됩니다.

테이블에 값을 삽입하는 또 다른 방법은 필드 이름별로 값을 순차적으로 나열하는 것입니다. 이러한 방식으로 데이터를 삽입하면 데이터를 저장할 열을 지정할 필요가 없습니다. 그러나 이러한 방식으로 INSERT 문을 작성할 때 INSERT 문에서 데이터가 지정되는 순서가 테이블에 대상 필드가 존재하는 순서와 동일하도록 특별한 주의를 기울여야 합니다. 다음 INSERT 문은 또한 직원 테이블에 새 레코드를 삽입합니다.

앞서 언급했듯이 INSERT 문에 데이터가 지정된 순서가 대상 테이블의 필드 순서와 일치하도록 특별히 주의해야 합니다. 따라서 예방책으로 대상 테이블을 검사하고 필드가 나타나는 순서를 기록해 두는 것이 좋습니다.
Database Structure 탭을 확인하면Employees 테이블의 구조를 관찰할 수 있습니다. 마지막으로 도입된 INSERT 문을 사용할 때 EmployeeId부터 Email까지의 필드 레이아웃을 이 정확한 순서로 지정해야 합니다.

## Updating Data and the SET Keyword 

UPDATE 문은 테이블의 기존 데이터를 수정하는 데 사용됩니다. 일반적으로 WHERE 절과 함께 사용됩니다. WHERE 절은 업데이트하려는 특정 데이터 행을 지정하기 위해 UPDATE 문과 함께 사용됩니다. WHERE 절이 없으면 UPDATE 문은 테이블에 포함된 모든 행을 업데이트합니다. 다음 문은 이전 섹션에서 삽입한 직원 레코드를 업데이트합니다.

 UPDATE 
employees
SET PostalCode = '11202'
WHERE
   EmployeeId = 9 
아직 직원을 추가하지 않은 경우 이 코드를 실행하면 "해당 열 없음" 오류가 발생합니다.

이전 구문에서 직원 테이블은 키워드 UPDATE 뒤에 지정됩니다. 다음으로 키워드 SET가 옵니다. 여기에서 업데이트하려는 직원 테이블의 열을 지정합니다. 이 예에서는 PostalCode 필드입니다. 그 뒤에 등호(=)와 이전 값을 업데이트하려는 새 값이 옵니다. 이 예에서 이 값은 '11202'입니다(우편번호는 문자열 값이므로 작은따옴표로 묶음). SET 키워드 다음에는 업데이트할 직원 레코드를 정확히 지정할 수 있는 WHERE 절이 있습니다. EmployeeId = 9를 지정하면 이 직원 레코드만 업데이트되고 다른 레코드는 업데이트되지 않습니다.

UPDATE 문에 WHERE 절을 포함하는 것은 특히 중요합니다. WHERE 절이 포함되어 있는지 확인하지 않고 의도한 레코드 수정을 지정하지 않으면 의도하지 않은 레코드를 업데이트할 수 있으며, 이는 심각한 역효과를 일으킬 수 있습니다.

즉시 UPDATE 문을 실행하는 대신 동일한 테이블과 WHERE 절을 사용하여 먼저 SELECT 문을 작성하십시오. 이렇게 하면 업데이트하려는 내용을 미리 볼 수 있습니다. SELECT 문이 예상 레코드를 반환하면 UPDATE 문을 실행할 수 있습니다.

## Deleting Data 

DELETE 문은 테이블에서 기존 레코드를 제거하는 데 사용됩니다. 이 문은 UPDATE와 같이 일반적으로 WHERE 절과 함께 사용됩니다. WHERE 절이 없으면 DELETE 문은 테이블에 포함된 모든 행을 삭제합니다. UPDATE에서 했던 것처럼 DELETE 문을 즉시 실행하는 대신 먼저 동일한 테이블과 WHERE 절을 사용하여 SELECT 문을 작성하십시오. 이렇게 하면 삭제하려는 내용을 미리 볼 수 있습니다. 선택 문이 예상 레코드를 반환하면 DELETE 문을 실행할 수 있습니다. 먼저 제거하려는 데이터를 확인하기 위해 SELECT 문을 만듭니다.

SELECT * FROM 
   employees
WHERE
   EmployeeId = 9 

이 데이터를 제거하고 싶다고 확신하면 다음 명령문은 이전 섹션에서 업데이트한 직원 레코드를 삭제합니다.
DELETE FROM 
   employees
WHERE
   EmployeeId = 9 

위의 DELETE 문은 DELETE FROM이라는 두 개의 키워드로 시작하고 그 뒤에 레코드를 삭제하려는 테이블의 이름이 옵니다. 이 예에서는 직원 테이블에서 레코드를 삭제합니다. 테이블 이름 다음에는 삭제할 직원 레코드를 정확히 지정할 수 있는 WHERE 절이 있습니다. EmployeeId = 9를 지정하면 이 직원 레코드만 삭제되고 다른 레코드는 삭제되지 않습니다.

ON YOUR OWN: » 위의 DELETE 문을 실행했을 때의 결과는 무엇입니까? » 또 다른 DELETE 문을 작성하고 영업 지원 에이전트인 모든 직원을 제거합니다. » 이전 질문에서 작성한 DELETE 문으로 인해 몇 개의 레코드가 영향을 받았습니까?

DELETE 문에 WHERE 절을 포함하는 것은 특히 중요합니다. WHERE 절이 포함되어 있는지 확인하지 않고 삭제할 레코드를 지정하지 않으면 의도하지 않은 레코드를 삭제할 수 있으며 이는 심각한 역효과를 일으킬 수 있습니다.


## Data Analysis Checkpoint






